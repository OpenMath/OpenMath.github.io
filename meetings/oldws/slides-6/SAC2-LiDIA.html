<HTML>
<HEAD>
<TITLE>Communication Interface between SAC--2 and LiDIA (25-Jul-1996)</TITLE>
<!-- Changed by: , 25-Jul-1996 -->


</HEAD>
<BODY>
<H2>Communication Interface between SAC-2 and LiDIA</H2>

<STRONG>G&aacute;bor A. Simon</STRONG><P>
Wilhelm-Schickard-Institut<BR>
Universit&auml;t T&uuml;bingen<BR>
Germany<BR>

<ADDRESS>simon@informatik.uni-tuebingen.de</ADDRESS>

<HR>
Unfortunately, the pictures are missing in this archive.
<HR>
<BLOCKQUOTE>
<UL>
<LI> <A HREF="#Motivation">Motivation</A>
<P>
<LI> <A HREF="#Proposition">Proposition</A>
<P>
<LI> <A HREF="#Is it realistic?">Is it realistic?</A>
<P>
<LI> <A HREF="#Sample Application">Sample Application</A>
<P>
<LI> <A HREF="#Conclusion">Conclusion</A>
<P>
<LI> <A HREF="#Relation to OpenMath">Relation to OpenMath</A>
<P>
<LI> <A HREF="#Future plans">Future plans</A>
<P>
</UL>


</BLOCKQUOTE>

<HR>
<A NAME="Motivation"></A>
<H2>Motivation</H2>

<UL>
<LI> In the development of computer algebra algorithms
one would frequently like to use (perhaps only temporarily) existing 
algorithms, which are implemented in different, possible incompatible systems.
<LI>This means, that one needs possibilities which allow the cooperation,
communication between programs, applications, objects and environments despite
differences in
implementation language, execution environment and model abstraction.
</UL>

There are a lot of computer algebra systems with different objectives.
<UL>
<LI> Huge, multipurpose systems (e.g., Mathematica or Maple etc.)
offering broad varieties of algorithms, which implies that it is impossible
to cope for them with the actual research state in every context.
<LI> Highly specialized systems (KANT, SIMATH,
SINGULAR, PARI-GP etc.) with very efficient implementations of the latest 
results in their particular field,
but these algorithms are only usable on the basis of their own system, because
of the tight coupling to the used arithmetic, memory management or model
abstraction.

</UL>
One possible way to make these innovative algorithms available
outside their native system is standardization (E.g., <STRONG>OpenMath</STRONG>).
But there is little indication that the trend towards this diversity will
drastically change, and even if the standardization activities become more 
and more stronger, the adaptation of the standards for all of these systems 
will take a long time.<P>

Our presented approach tries to use available industrial standards and 
techniques to 
solve these problems. We will discuss the advantages and disadvantages of this 
attempt and show what parts have to be supplied by the application developer and
what can be automatically generated by tools.



<A NAME="Proposition"></A>
<H2>Proposition</H2>
<!-- IMG ALIGN=TOP SRC="SAC2-LiDIA-gifs/interface.gif" ALT="interface" -->

<UL>
<LI> A system should  be constructed as a set of <EM>interacting objects</EM>. 
It enables  the implementation of  different objects in different
programming languages. In order to enable interaction between such objects,
one needs to abstract the functionality provided by each object by clearly 
defined  interfaces.
<LI> Tools should help to reduce the complexity of developing distributed 
applications.
<LI> The developer of an application should not need detailed knowledge 
about the internals of the  foreign systems to use their services exported 
by an server application.
<LI> Users of the client application should not have to care about localizing a
server application, they should be found automatically.
</UL>


<A NAME="Is it realistic?"></A>

<H2>Is it realistic?</H2>
Distributed object managers as e.g, CORBA (Common Object Request Broker 
Architecture) makes distributed application development easier,
providing an infrastructure.<P>


<UL>
<LI> The Object Management Group, (OMG) is a consortium of
<A HREF="http://www.omg.org/member-list.html">
software vendors and end users</A>.

<LI> <A HREF="http://www.omg.org/corba.htm">CORBA</A>
provides the mechanisms by which objects transparently make
requests and receive responses, as defined by OMG's ORB.
The CORBA ORB provides interoperability between applications
built in (possibly) different languages, running on (possibly) different 
machines in heterogeneous distributed environments.

</UL>

<H3>Inter-Language Unification<A HREF="ftp://beta.xerox.com/pub/ilu/ilu.htm"> (ILU)</A></H3>
Xerox Corporation PARC

<UL>
<LI> CORBA like

<LI> idl2isl convert CORBA IDL to ILU ISL

<LI> Interoperability

<UL>
<LI> Between different programming languages
(Common Lisp, Modula-3, ANSI C, C++, Java, FORTRAN, ...)

<LI> Between different operating systems
(UNIX, Windows NT, MacOS, ...)

<LI> Between different binding models
(same (IPC) or different address space (RPC))

<LI> using different RPC protocols
(ONC RPC, XNS Courier, DCE RPC, OMG CORBA)
</UL>
</UL>


<H3>ILU specific features</H3>

<MENU>
<LI> Network garbage collection for objects

<LI> Unicode support

<LI> The <TT>OPTIONAL</TT> type, which allows recursive data structures

<XMP>
TYPE OptNode = OPTIONAL Node;
TYPE Node = RECORD
     data:      SomeType,
     left:      OptNode,
     right:     OptNode
END;
</XMP>
</MENU>
<H3>ILU Interface Specification Language (ISL)</H3>

<UL>
<LI> ISL is a declarative language which allow the definition of
object types (with methods) and attributes.

<LI> An ISL interface contains four kinds of statements:
<UL>
 <LI> the interface header,

<LI> type declarations,

<LI> exception declarations,

<LI> constant declarations.
</UL>

<LI> Constructors for specifying complex data types are: ARRAY, SEQUENCE, RECORD
,
UNION, OPTIONAL, ENUMERATION, OBJECT.

<LI> The <TT>In</TT>, <TT>Out</TT>, and <TT>InOut</TT> ISL specifications indicate that the associated argument
is to be read only, write only, or read/write respectively. These indications
in an ISL interface definition tell the  stubber to either
send the argument data, receive the argument data, or both.
</UL>
<H3>Stubber and Runtime Library</H3>

<UL>
<LI> The stubber typically generates a stub source file for clients, a stub 
file for servers, and an include file of interface definitions.
E.g. the c-stubber generates the following files:
<UL>
<LI> <TT>InterfaceName-surrogate.c</TT> client specific file, used by users 
of the modules (naming convention: <TT>Interface_Type_Method</TT>)

<LI> <TT>InterfaceName-true.c</TT> server specific file, used by implementors of the modules (naming convention: <TT>server_Interface_Type_Method</TT>)

<LI> <TT>InterfaceName-common.c</TT> functions common to both client and server

<LI> <TT>InterfaceName.h</TT> include file for the stubs
</UL>
<LI> Client stubs and server stubs automat the following activities (in
conjunction with the ILU Kernel and the language specific runtime libraries (LSRL):

<UL>
<LI> Object location and binding

<LI> Parameter marshalling and demarshalling
</UL>


<LI> The language specific runtime system is responsible for interfacing
between the generated stubs, client, server and the ILU kernel.
It must initialize the kernel, register objects, and respond to messages sent.

</UL>


<A NAME="Sample Application"></A>
<H2>Sample Application</H2>

Using the  following sample problem, we will  demonstrate the 
main steps the developer has to do to build an application based on 
interoperable objects.<BR><BR>

The client application generates a matrix with arbitrary precision coefficients, sending a request to the LiDIA server to compute its determinant,
and receiving the result or some error messages.<BR><BR>

The first step is to build a server application, based on the interface definition using a selected subset of the LiDIA objects. The LiDIA package is implemented in C++.<BR><BR>

The client application is written in ALDES, using the SAC-2 library. We used an
ANSI C backend for the ALDES implementation. That is why the communication specific part is written in C. The client application has to convert the arguments 
of the requested LiDIA methods, if the arguments do not match the interface 
used by the LiDIA server.<BR><BR>

As the next Figure shows, both the client and server applications have 
several parts, libraries and automatically generated stubs.<BR><BR>

<!-- IMG ALIGN=MIDDLE SRC="SAC2-LiDIA-gifs/ilu-det.gif" ALT="ilu-det" -->



<H3>Server and Client-side Components of the Application</H3>



<UL>
<LI> Server-side
     <UL>
<LI> ISL Specification
<LI> Method Definition and Implementation

<LI> Main Server Program
</UL>

<LI> Client-side
     <UL>
<LI> Generated Stubs

<LI> Method Activation

<LI> Conversion modules

</UL>
       
</UL>

<!-- IMG ALIGN=MIDDLE SRC="SAC2-LiDIA-gifs/scheme.gif" ALT="scheme" -->

<H3>Server-side ISL Specification</H3>

Defines the interface between client and server.

<LISTING>
INTERFACE det;
EXCEPTION DivideByZero;
EXCEPTION NumTooBig;
TYPE BigIntBJEC = OBJECT
  METHODS
   isbiggerthan ( x : INTEGER) : BOOLEAN,
   setValue ( w : INTEGER),
   setbigValue ( bw : BigInteger),
   getValue () : INTEGER RAISES NumTooBig END,
   add ( a : INTEGER),
   bigadd ( ba : BigInteger),
   mul ( m : INTEGER),
   divrem (d : INTEGER) : INTEGER RAISES DivideByZero END
  END;
TYPE BigIntMatriC = OBJECT
  METHODS
   setnorows (y : INTEGER),
   setnocolumns (x :INTEGER),
   setelem (x :INTEGER, y :INTEGER, e : BigInteger)
  END;
TYPE bigintlib = OBJECT
  METHODS
    bigint ( wert : INTEGER ) : BigInteger,
    bigintmatrix () : BigIntMatrix,
    mul ( b : BigInteger, c : BigInteger) : BigInteger,
    determ ( a : BigIntMatrix) : BigInteger
  END;
</LISTING>


This defines an interface <TT>det</TT>, exceptions <TT>DivideByZero</TT> and
<TT>NumTooBig</TT>, object types <TT>BigInteger, BigIntMatrix</TT> and
<TT>bigintlib</TT>. The interface, <TT>det</TT>, is a way of grouping a number o
f type
and exception definitions.  This is important to prevent collisions
between names.

<H3>Server-side Method Definitions</H3>
The developer writes C++ definitions for the methods:
<LISTING>
...

class BigIntMatrix : public det_T_BigIntMatrix {
public:
  BigIntMatrix();  // constructor

// methods
  void setnorows (detStatus *_status, long int y);
  void setnocolumns (detStatus *_status, long int x);
  void setelem (detStatus *_status, long int x, long int y,
        class det_T_BigInteger *e);
// data
  bigint_matrix M;
};
...
void
BigIntMatrix::setelem(detStatus *_status, long int x, long int y,
                      class det_T_BigInteger *e)
{
  M.sto(x,y, ((class BigInteger *)e)->Wert);
  _status->returnCode = detReply_Success;
}

...
</LISTING>

<H3>Writing Main Server Program</H3>

<LISTING>
...

int
main (int argc, char *argv[])
{
  det_T_bigintlib *i;

  iluServer s("det-server", NULL);

  s.AddPort (NULL, NULL, ilu_TRUE);

  ilu::SetDefaultServer(&s);

  i = new bigintlib("BIGINT", &s);

  if (!i->ILUPublish()) {
    cerr << "**** Error, couldn't publish object\n" ;
    exit(1);
  }

  cout << "Exported " << i->ILUStringBindingHandle() << "\n";

  s.Run();
}

</LISTING>


<H3>Binding a Client to a Target Object</H3>
Steps for binding a client to a target object:

<OL>
<LI> A client obtains an <CITE>object reference</CITE> from the server (<CODE>det_server_
connect</CODE>).
This object reference serves as a local proxy for the remote target object.
 
  <UL>
<LI> Object references may be passed as parameters to other remote objects
     (<CODE>m = det_bigintlib_bigintmatrix(l,&env);</CODE>).
</UL>
 

<LI> The client may then invoke methods on its proxy.

</OL>


<H3>Client-side Example</H3>
The client programmer writes the following:
<LISTING>
#include "det.h"

#define ERRCHECK  if (!ILU_C_SUCCESSFUL(&env))
          { fprintf (stderr, "error signalled <%s>.\n",
                  ILU_C_EXCEPTION_ID(&env)); exit(1); }
int
LiDDET(int M)
{
  int time;
  /* LiDIA variables */
  det_bigintlib l;
  det_BigIntMatrix m;
  det_BigInteger e;
  det_BigInteger d;
  /* ALDES/SAC-2 variables */
  extern int SPACE[], BETA, BETA1;
  /* ILU variables */
  ILU_C_ENVIRONMENT env;
  ...
  extern int libi2abi();
  extern det_BigInteger abi2libi();
  extern det_bigintlib det_bigintlib_determ();

  l = det_server_connect();
</LISTING>
 <LISTING>
 /* creating LiDIA - BigIntMatrix m */
  ...

  d = det_bigintlib_determ (l, &env, m); ERRCHECK;
  time = CLOCK()-time;

  printf("execution time : %d ms\n", time);

  /* get back the result and convert to SAC-2 format */
  time = CLOCK();
  D = libi2abi( d);
  time = CLOCK()-time;

  printf("transf.+conv. of the determinant d : %d ms\n", time);

  return D;
}
</LISTING>
<A NAME="Conclusion"></A>
<H2>Conclusion</H2>

<UL>
<LI> <STRONG>Advantages</STRONG>

<UL>
<LI> The main advantage of the CORBA approach is the universality. One can 
use the same technique not only between CA systems, but in connection with 
graphic (e.g., FRESCO), numeric, or database libraries.
<LI> Some convenient features of the communication (server lookup etc.).
</UL>


<LI> <STRONG>Disadvantages</STRONG>

<UL>
<LI> The lack of special facilities for algebraic structures and contexts.
</UL>

</UL>


<A NAME="Relation to OpenMath"></A>
<H2>Relation to OpenMath</H2>
<UL>
<LI> The use of interfaces describing the functionality of the exported 
objects allows a great flexibility. This enables the implementation of 
server
applications using an export interface on the basis of OpenMath even if the 
internal representation is totally different. (Sutor: Object Standard?)<BR>

This means that the server stubs, generated from the
OpenMath conform interface, should be extended with the necessary 
conversions mapping the external representation onto the internal 
implementation.

<LI> In this case, the client applications are working only with the 
external representation defined in the interface definition.
</UL>




<A NAME="Future plans"></A>
<H2>Future plans</H2>

<UL>
<LI> It would be interesting to rebuild an OpenMath 
prototype application using this technique. (MathEdge)
<LI> Dynamic interface invocation<BR>
The interface definition which a client program can use is determined at
compile time. Hence the client code is limited to  using those servers
which contain objects that provide the interface selected by the client 
when building an application.

Dynamic interface invocation allows an application to issue requests
for any interface, even if it was unknown at compile time. 
<LI> High level interface definition language, with 
     algebraic type information. (Schupp, <TT><B>SUCH THAT</B></TT>)
</UL>

<HR>
This page is part of the OpenMath Web archive,
and is no longer kept up to date.

</HTML>
